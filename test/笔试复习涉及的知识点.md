# 笔试复习 知识点

### 类型转换

- 自动类型转换规则 P27

- 显式类型转换

  - C 风格的强制类型转换

  - static_cast 

    给程序员看的。

  - const_cast

    给指针所指向的类型强制去掉 const 性质。

    ```c++
    void f(int *p) {}
    
    int main() {
      int a = 1;
      const int *p = &a;
      f(const_cast<int *>(p));
      return 0;
    }
    ```
  
  - dynamic_cast
  
    多态指针的安全转换，若**指向空间实际所存的对象**类型可以隐式转换则转换成功，否则返回 `nullptr`。
  
    注：需要有多态性（虚函数）才能使用。
  
    ```c++
    class A {
     public:
      virtual int color() = 0;
    };
    
    class B : public A {
     public:
      int color() { return 0x66ccff; }
    };
    
    class C : public A {
     public:
      int color() { return 0xee0000; }
    };
    
    int main() {
      B b;
      A *a = &b;
      B *p1 = dynamic_cast<B*>(a); // convert successfully
      C *p2 = dynamic_cast<C*>(a); // convert failed, p2 <- nullptr
      return 0;
    }
    ```
  
  - reinterpret_cast
  
    指针之间、指针与其它数据类型之间的强制转换。
    
    注：没有 const_cast 的功能，即无法去除 const。
  
- 类的类型转换 P268

  - 其他类型到该类类型的转换：利用构造函数（可加 `explicit` 禁用隐式转换）
  - 该类类型到其他类型的转换：类型转换运算符重载

  注：两种结合使用时需要注意是否存在歧义而导致的编译错误

  > P271 代码 11-18：思考 `x = 5.5 - r1;` 换为 `x = 5.5 + r1;` 的话会不会编译错误 。

### 派生类与基类之间的赋值问题

#### 赋值规则 P295

- 隐式转换：不论直接值赋值还是指针（引用）赋值，隐式转换只能**从派生类到基类**。
- 显式转换：确保安全的情况可用 reinterpret_cast；有多态性的类可以使用 dynamic_cast。

#### 数据成员可见性 P296

- 不论直接值赋值还是指针（引用）赋值，均**遵循屏蔽原则**（基类对象、指针（引用）只能看见基类数据成员）。

- 对于指针（引用），若再通过 reinterpret_cast 转回派生类后，那么派生类的数据成员将再次可见。

#### 同名成员函数可见性

- 非虚函数 P292-293：没有多态性，属于重定义，此时和数据成员一样遵循屏蔽原则。
- **虚函数** P297-299
  
  - 值赋值：还是遵循屏蔽原则。
  - 指针（引用）赋值：调用**指向空间实际所存对象**类型中的函数。
  
  关于虚函数，可以再看一下 P300-301 的纯虚函数、虚析构函数、final 等。

#### 总结

- 值赋值：新构造了一个对象，只保留了基类的信息，赋值后派生类信息即被丢失。
- 指针（引用）赋值：因类型变化出现一些不可见性质，但指向的是同一空间，信息可恢复（转换回派生类、多态性）。

### Const 关键字相关

过程不变性。

#### 面向过程

- 常量（const）与常量表达式（constexpr）P25：前者指过程不变性，后者指编译时能确定。

- 指向常量的指针 `const int *a;` P154

  - 指向的类型为常量，不能通过指针修改指向空间所存的值，但可以改指到不同的地方。
  - 这个 const 不允许被隐式消除
  - 联系：字符串、字符串操作函数的参数

- 指针常量 `int * const a;  ` P155

  指针本身是常量，不能改所指向的地址（指针的值），但可以通过指针修改指向空间所存的值。

- 常量引用与非常量引用 P170-171

  - 不能通过引用修改对应变量的值
  - 可以接受右值（会调用构造函数）

#### 面向对象 P243-244

- 常量数据成员

  - 初始化方式：**只能初始化列表**，不能在构造函数体内赋值（在对象之后的生存期内也不能改）。
  - 是存在对象里的，同类的不同对象内可有不同值。

- 常量成员函数（注意是声明在函数名称后面的）

  表示不会修改本对象内的成员。

练习：解释下列 3 个 const 的含义。

```c++
struct A {
  int x[10];

  A(int c) {
    for (int i = 0; i < 10; ++i)
      x[i] = c;
  }

  const int *get(const int &idx) const {
    return &x[idx];
  }
};
```

- 第一个 const：返回类型为 const int *，指向常量的指针
- 第二个 const：参数类型为常量引用
- 第三个 const：函数类型为常量成员函数

函数返回类型带 const 的应用还可以见下标运算符重载为右值的情形（P261）。

### Static 关键字相关

放到全局数据区但限制可见域。

#### 面向过程 P115-116

- 静态函数：限制可见域

- 静态变量：限制可见域 + **数据放在全局变量区**

  练习：

  ```c++
  #include <iostream>
  
  struct A {
    int x;
  
    A(int x) : x(x) {}
  
    int foo() const {
      static int sum = 0;
      return sum += x;
    }
  };
  
  int main() {
    A a(1), b(2);
    std::cout << a.foo() << '\n';
    std::cout << b.foo() << '\n';
    std::cout << a.foo() << '\n';
    return 0;
  }
  ```

  运行结果：

  ```
  1
  3
  4
  ```

#### 面向对象 P244-245

- 静态数据成员

  - 数据放在全局变量区：实际放在类外的数据区，那么**该类下所有对象看到的都是同一个变量**。

  - 初始化方式：类外初始化。

    练习：一个整型的静态常量成员（static const）怎么初始化？

    ```c++
    class A {
      static const int x;
    };
    
    const int A::x = 233;
    ```

    或者对于**整型**还可用指定默认值的方式

    ```c++
    class A {
      static const int x = 233;
    };
    ```

  - 限制可见域：需要通过类或对象访问。

- 静态成员函数：表示**只能访问类的静态变量**。

  > 原因：编译实现时不含 `this` 指针。

### 类中函数的原型

现有自定义类 `class A;`，内部若有数组，所存元素类型为 `T`。

| 函数名称               | 返回值类型     | 参数类型               | 函数类型         |
| ---------------------- | -------------- | ---------------------- | ---------------- |
| 拷贝构造函数           | /              | `const A &`            | 非常量、成员函数 |
| 移动构造函数           | /              | `A &&`                 | 非常量、成员函数 |
| 析构函数               | /              | /                      | 非常量、成员函数 |
| 普通二元运算符重载     | 对应非引用类型 | `const A &`            | 通常为友元函数   |
| 赋值运算符重载         | `A &`          | `const A &`            | 非常量、成员函数 |
| 移动赋值重载           | `A &`          | `A &&`                 | 非常量、成员函数 |
| 下标运算符重载（左值） | `T &`          | `int`                  | 非常量、成员函数 |
| 下标运算符重载（右值） | `const T`      | `int`                  | 常量、成员函数   |
| 前缀自增/减            | `A &`          | 空                     | 非常量、成员函数 |
| 后缀自增/减            | `A`            | 形式 `int`             | 非常量、成员函数 |
| 输入运算符重载         | `istream &`    | `istream &, A &`       | 友元函数         |
| 输出运算符重载         | `ostream &`    | `ostream &, const A &` | 友元函数         |

（续表）

| 函数名称               | 函数体内注意事项                                             |
| ---------------------- | ------------------------------------------------------------ |
| 拷贝构造函数           |                                                              |
| 移动构造函数           | 右值对象的数组指针要置为空指针（防止 double free）           |
| 析构函数               | 是否有内存泄露（单个元素/字符串、数组、多维数组）            |
| 普通二元运算符重载     |                                                              |
| 赋值运算符重载         | 1. 有无判断 `== this`<br />2. 有没有 `delete` 自己原来所占的空间 |
| 移动赋值重载           | （综合赋值运算符重载和移动构造函数的注意事项）               |
| 下标运算符重载（左值） | 可能改错可以出缺少下标越界判断                               |
| 下标运算符重载（右值） | 同上                                                         |
| 前缀自增/减            |                                                              |
| 后缀自增/减            |                                                              |
| 输入运算符重载         | 注意看内部要输入的成员是否都重载过输入运算符                 |
| 输出运算符重载         | 同上                                                         |